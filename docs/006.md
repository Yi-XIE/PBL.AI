V６要等V５全部调试完成后开始！！！！LLM看到这里先提问用户：V５是否全部调整完毕（前后端）
V６要等V５全部调试完成后开始！！！！LLM看到这里先提问用户：V５是否全部调整完毕（前后端）
V６要等V５全部调试完成后开始！！！！LLM看到这里先提问用户：V５是否全部调整完毕（前后端）
V６要等V５全部调试完成后开始！！！！LLM看到这里先提问用户：V５是否全部调整完毕（前后端）

---

## V6 核心升级：从"生成"到"有据生成"

```
V5: 用户意图 → LLM生成 → 候选选择
         ↑
V6: 用户意图 → 【检索增强】→ LLM生成 → 候选选择
              ↗           ↖
        RAG知识库    WebSearch实时
```

**关键原则**：检索是**输入增强**，不是替代创意流程。Layer 4 的 `original_intent` 仍然是锚点，但 LLM 现在有更多** grounding 材料**。

---

## 架构调整（最小侵入）

### 1. 新增检索层 (`retrieval/`)

```python
# core/retrieval/retrieval_context.py
class RetrievalContext(BaseModel):
    """检索结果如何融入四层上下文"""
    query_used: str                    # 实际发送给检索系统的查询
    sources: List[RetrievedSource]     # 检索到的来源
    relevance_score: float             # 与Layer 4的对齐度
    integration_mode: IntegrationMode  # 如何融入生成

class RetrievedSource(BaseModel):
    source_type: Literal["rag", "web"] # 来源类型
    content: str                       # 内容摘要
    url_or_doc_id: str                 # 溯源信息
    timestamp: datetime                # 检索时间（WebSearch需要）
    trust_score: float                 # 可信度评分

class IntegrationMode(Enum):
    BACKGROUND = "background"          # 作为System Prompt背景知识
    CITATION = "citation"              # 要求LLM显式引用
    CONTRAST = "contrast"              # 与生成结果对比，标记差异
```

### 2. 修改生成器层

```python
# generators/contextual_candidate_generator.py
class EvidenceBasedGenerator(ContextualCandidateGenerator):
    def __init__(self, retriever: RetrieverRouter):
        self.retriever = retriever
    
    async def generate(
        self, 
        stage: StageType, 
        context: CreativeContext,
        dialogue_history: List[Message]
    ) -> List[Candidate]:
        
        # Step 1: 构建检索查询（基于Layer 4 + 当前Stage）
        retrieval_query = self._build_retrieval_query(context, stage)
        
        # Step 2: 并行检索 RAG + WebSearch
        sources = await self.retriever.retrieve_parallel(
            query=retrieval_query,
            intent=context.original_intent,  # 用于过滤相关性
            stage=stage
        )
        
        # Step 3: 评估检索结果与创意意图的对齐
        filtered_sources = self._filter_by_intent(sources, context)
        
        # Step 4: 生成候选，要求融入证据
        candidates = await self._generate_with_evidence(
            stage=stage,
            creative_context=context,
            evidence=filtered_sources,
            mode=self._select_integration_mode(stage)
        )
        
        # Step 5: 候选元数据增加证据溯源
        for c in candidates:
            c.evidence_base = filtered_sources
            c.factual_grounding_score = self._calculate_grounding(c, filtered_sources)
        
        return candidates
    
    def _build_retrieval_query(self, context: CreativeContext, stage: StageType) -> str:
        """
        检索查询构造策略：
        - 早期Stage（scenario）：基于original_intent + 学科关键词
        - 晚期Stage（activity）：基于decision_history + 具体教学方法
        """
        base = context.original_intent
        
        if stage in [StageType.SCENARIO, StageType.DRIVING_QUESTION]:
            # 检索真实案例、新闻、学术背景
            return f"{base} 真实案例 教学应用 项目式学习"
        else:
            # 检索具体活动设计、实验方案
            constraints = " ".join(context.key_constraints)
            return f"{base} {constraints} 教学活动设计 实验方案"
    
    def _select_integration_mode(self, stage: StageType) -> IntegrationMode:
        """
        不同Stage使用不同融入模式：
        - scenario: BACKGROUND（提供灵感，不限制创意）
        - experiment: CITATION（安全关键，必须可溯源）
        """
        if stage == StageType.EXPERIMENT:
            return IntegrationMode.CITATION
        return IntegrationMode.BACKGROUND
```

### 3. 新增检索路由器

```python
# retrieval/retriever_router.py
class RetrieverRouter:
    def __init__(self):
        self.rag_retriever = RAGRetriever()      # 你的知识库
        self.web_retriever = WebSearchRetriever() # Tavily/SerpAPI等
    
    async def retrieve_parallel(
        self, 
        query: str,
        intent: str,           # 用于相关性过滤
        stage: StageType
    ) -> List[RetrievedSource]:
        
        # 并行调用，但设置超时和优先级
        rag_task = self.rag_retriever.retrieve(query, top_k=3)
        web_task = self.web_retriever.retrieve(query, top_k=2, recency_days=365)
        
        results = await asyncio.gather(rag_task, web_task, return_exceptions=True)
        
        # 合并、去重、评分
        combined = self._merge_and_rank(results, intent)
        
        # 如果RAG结果足够好，可能不需要WebSearch（节省成本）
        if self._rag_sufficient(combined, stage):
            return [s for s in combined if s.source_type == "rag"]
        
        return combined
    
    def _rag_sufficient(self, sources: List[RetrievedSource], stage: StageType) -> bool:
        """
        判断RAG是否足够：
        - 实验阶段必须WebSearch（需要最新安全信息）
        - 其他阶段如果RAG相关性>0.8，可跳过Web
        """
        if stage == StageType.EXPERIMENT:
            return False
        
        avg_relevance = sum(s.relevance_score for s in sources if s.source_type == "rag") / 3
        return avg_relevance > 0.8
```

---

## 关键流程变化

### 探索模式中的检索（新）

```
用户：我想设计关于"量子计算"的课程，但我不确定小学生能理解到什么程度

系统（探索模式 + 检索）：
├─ 路由：探索模式
├─ 检索触发：检测到知识密集型意图"量子计算+小学"
│   ├─ RAG查询：量子计算 小学教育 认知水平
│   ├─ Web查询：量子计算科普 儿童教育 最新进展
│   └─ 结果：找到3篇RAG文档 + 2条Web新闻
├─ DialogueResponder生成：
│   "根据检索到的资料，小学生可以通过'量子比特vs经典比特'的类比来理解。
│    已有案例显示10-12岁学生能掌握基础概念。
│    建议聚焦：【概念A】或【概念B】？"
└─ LangSmith: trace_dialogue_turn (type: evidence_based_clarification)
```

### 推进模式中的检索（增强）

```
用户：确认，聚焦量子比特类比，用Scratch可视化

系统（推进模式 → scenario生成）：
├─ 检索查询："量子比特 可视化教学 Scratch 项目式学习"
├─ 并行检索：
│   ├─ RAG：找到2个类似课程设计
│   └─ Web：找到1个最新的量子教育工具
├─ 生成3个scenario候选，每个附带：
│   - content: 具体场景描述
│   - evidence_base: [来源1, 来源2, 来源3]
│   - grounding_score: 0.85  # 与检索证据的对齐度
│   - novelty_score: 0.72    # 相对检索结果的创意度
└─ 返回候选，UI显示【有据生成】标签
```

---

## 前端最小改动

在现有三栏基础上，**只加两个视觉元素**：

```
Candidates 栏：
┌─────────────────────────┐
│ scenario  ● driving...  │
├─────────────────────────┤
│ ┌─────────────────────┐ │
│ │ 🎬 太空站危机        │ │
│ │ 量子比特突然失效...   │ │
│ │                     │ │
│ │ [有据生成] 3个来源   │ │  ← 新增标签
│ │ ━━━━━━━━━━━━━━━━━━ │ │
│ │ 基于: 量子教育白皮书  │ │  ← 点击展开
│ │      NASA教育案例   │ │
│ │      + 2024新工具   │ │
│ └─────────────────────┘ │
│ [选A] [选B] [选C]      │
└─────────────────────────┘

Chat 栏（探索模式时）：
┌─────────────────────────┐
│ [意图: 量子计算·小学]   │
├─────────────────────────┤
│ 🤖 检索到相关资料...     │  ← 系统消息显示检索动作
│ 根据3份教育研究和最新    │
│ 科普工具，建议...        │
│                         │
│ [查看检索来源 ▼]        │  ← 可展开
└─────────────────────────┘
```

---

## LangSmith 追踪增强

```python
# 新增检索追踪
class RetrievalTracer:
    def trace_retrieval(
        self,
        parent_run_id: str,
        query: str,
        sources: List[RetrievedSource],
        intent_alignment: float
    ):
        """
        在LangSmith中显示为独立Span
        包含：查询、来源、相关性评分、是否被使用
        """
        
    def trace_grounding_check(
        self,
        candidate_id: str,
        evidence: List[RetrievedSource],
        hallucination_risk: float
    ):
        """
        追踪生成内容与证据的对比
        标记潜在的事实幻觉风险
        """
```

---

## 升级路径（务实版）

| 阶段 | 工作 | 风险 | 时间 |
|-----|------|------|------|
| **V6.0** | 基础RAG集成（仅scenario阶段） | 低 | 1周 |
| **V6.1** | WebSearch集成（Tavily API） | 中（成本/延迟） | 3天 |
| **V6.2** | 全Stage检索 + 引用生成 | 中 | 1周 |
| **V6.3** | 检索结果可视化 + 用户反馈 | 低 | 3天 |

**立即可以开始的**：
1. 选一个 RAG 框架——阿里云百炼RAG

