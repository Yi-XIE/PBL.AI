# 重构指南（架构，从0搭建 + LangSmith）

本文件面向新的 Codex，从零开始重建系统架构。目标是完整实现 `docs/design/004.md` 的能力，并内置 LangSmith 监控。

**核心目标**
1. 支持多起点：`scenario` 与 `tool_seed`。
2. 支持反向补全：缺依赖时自动补齐前置阶段。
3. 每个 Stage 生成 ≥3 个候选方案，用户可选择或反馈。
4. 分支可追溯，选择后冻结其他候选，不支持跨 Stage 回退。
5. 流程可解释：用户知道“当前阶段 / 原因 / 下一步”。
6. 提供 REST API + SSE 事件流 + 可选 UI。
7. LangSmith 全链路监控，支持按 `task_id` 回放。

**必须保留的架构要点（不可删改）**
1. 四条核心原则：流程可感知、决策可解释、用户随时介入、依赖由系统硬编码管理。
2. 角色边界：流程引擎只做依赖/分支/约束，不生成不解释不对话；LLM 只做生成/解释，不管理状态。
3. Tool Seed 作为正式入口，并保持反向补全与双重约束（`tool_seed + question_chain`）逻辑。
4. 反向补全必须先解释再建议，不得隐式推进。
5. 多候选强制 + 候选元数据结构（`rationale` / `derived_from` / `alignment_score` / `generation_context`）。
6. 分支冻结与不可回退：选择后冻结，未选保留至 Task 完成，选择历史永久保留，不跨 Stage 回退。
7. Activity 双重对齐与冲突流程（A/B/C 方案 + 等待用户决定）。
8. Hidden Flow Graph 语义节点链路必须保留（entry → dependency_check → require_previous → candidate_stage → user_choice_gate → stage_finalize）。
9. Task / StageArtifact / ToolSeed 数据模型字段语义保持一致。
10. 至少三条降级策略：LLM 不可用、依赖循环、用户长时间不选择。

**最优方案概览（建议）**
1. 以“显式状态机 + 事件流”作为核心骨架，所有状态变化以事件驱动，确保可回放与可审计。
2. 领域模型独立于框架，API 只做编排，LLM 只做生成，不参与流程控制。
3. 依赖规则放在 `core/`，决策逻辑放在 `engine/`，避免生成节点隐式篡改流程。
4. LangSmith 作为全局观测层，贯穿 Decision、Generator、Validator 与 API 行为。

**架构分层与职责**
- UI 层：展示进度、候选选择、消息解释、冲突处理。
- API 层：会话创建、行动提交、进度查询、事件推送。
- 任务管理层：Task 生命周期、阶段状态、进度计算。
- 决策层：依赖检查、下一步阶段、用户解释。
- Stage 生成层：结构化候选生成与选择。
- Hidden Flow Graph：依赖图与分支记录，对用户不可见。
- 知识与工具层：知识模板与 Tool Seed 约束。
- 观测层：LangSmith 追踪与审计。

**必须实现的数据模型**
- `Task`
  - 字段：`task_id` `session_id` `entry_point` `current_stage` `completed_stages` `status` `entry_data` `artifacts` `created_at` `updated_at`
- `StageArtifact`
  - 字段：`stage_type` `status` `candidates[]` `selected_candidate_id` `generation_context` `warnings[]` `revision_id`
- `Candidate`
  - 字段：`id` `content` `rationale` `derived_from` `alignment_score` `status`
- `ToolSeed`
  - 字段：`tool_name` `algorithms[]` `affordances[]` `constraints{}` `user_intent`
- `DecisionResult`
  - 字段：`next_stage` `direction` `explanation` `user_message` `constraints`
- `Conflict`
  - 字段：`warnings[]` `conflict_options[]` `recommendation`

**标准阶段与依赖**
- Stage 顺序：`scenario` → `driving_question` → `question_chain` → `activity` → `experiment`
- 基础依赖：
  - `driving_question` 依赖 `scenario`
  - `question_chain` 依赖 `driving_question`
  - `activity` 依赖 `question_chain`
  - `experiment` 依赖 `activity`
- Tool Seed 入口依赖（必须支持）：
  - `scenario` 依赖 `tool_seed`
  - `activity` 依赖 `question_chain` + `tool_seed`

**核心流程（从0搭建时必须保持）**
1. 创建 Task，确定 `entry_point`。
2. 依赖检查：若缺失则触发反向补全，返回解释与下一步。
3. 生成候选：每次生成 3 个候选 + 结构化元数据。
4. 用户选择或反馈：选择后锁定分支，反馈则按规则重生成。
5. Stage 完成落盘：更新 `Task` 与 `StageArtifact`。
6. 进入下一 Stage，直至完成。

**关键规则（必须写死，避免翻车）**
1. Stage 完成判定必须同时满足：存在 `selected_candidate_id`；对应 `candidate.status == "selected"`；Validator 未返回 blocking conflict。
2. 反向补全是“建议”而非“隐式执行”：依赖缺失时必须先返回 `explanation + next_step` 给用户，不允许直接自动生成缺失 Stage 作为隐式决策。
3. LangSmith Run 粒度：禁止在一个 Run 中完成多个 Stage 的生成，每个 Stage 必须独立 Run，避免回放边界模糊。

**隐藏流程图（对用户不可见）**
- 记录每次候选与选择的分支图，支持回放与审计。
- 选择后冻结未选分支，不支持跨 Stage 回退。

**LangSmith 监控（必须内置）**
1. 为每个 Task 建立根 Run，`run_name=task_id`，`metadata` 携带 `entry_point` 与当前 Stage。
2. 子 Run 至少覆盖以下模块：Decision、Generator、Validator、API Action。
3. 关键输入输出进入 trace，但对敏感字段做脱敏或摘要。
4. 每次用户动作（accept/select/regenerate/resolve_conflict）必须记录到 trace。
5. 失败与异常必须进入 LangSmith 作为 error 事件。

**推荐目录结构（新项目）**
```text
new_root/
  core/           # 领域模型与依赖规则
  engine/         # 流程控制与依赖检查
  generators/     # Stage 生成器与候选输出
  validators/     # 对齐校验与冲突检测
  services/       # 任务管理、解释生成、消息聚合
  adapters/       # LLM / 存储 / 搜索 / 外部工具
  api/            # FastAPI 路由与 DTO
  ui/             # Web UI
  tests/          # 关键链路测试
```

**最小可用交付物（架构视角）**
1. 能从 `tool_seed` 或 `scenario` 开始完整走通 5 个 Stage。
2. 每个 Stage 至少 3 个候选，并能选择与锁定分支。
3. 依赖缺失时自动补齐并给出解释。
4. `Task` 与 `StageArtifact` 可持久化或至少可序列化。
5. LangSmith trace 可按 `task_id` 回放完整链路。
