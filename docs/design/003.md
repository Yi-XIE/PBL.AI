
## AI+PBL Agent 架构（LLM 决策 · 过程可感知 · 协作式生成）

> 本文档已被 `docs/design/004.md` 替代，请以 004 为准。

**状态**：Draft（可实施版）
**日期**：2026-02-20
**作者**：Jason Xie

---

## 1. 设计背景

### 1.1 为什么去掉 ReAct / LangGraph 显式推理

在 v2.0 讨论中，我们引入了 ReAct 与 LangGraph，试图解决：

* AI 在做什么？
* 为什么下一步是这个？
* 流程是否智能推进？

**但在实际体验与实现评估中发现：**

1. **ReAct 的推理过程对用户价值极低**

   * 用户不关心 Thought / Act / Observe
   * 他们只关心：*现在在干嘛、为啥、我要不要管*

2. **ReAct 增加了工程复杂度**

   * Prompt 复杂
   * 状态多
   * Debug 成本高

3. **“智能感”不来自推理格式**

   * 而来自：

     * 决策是否合理
     * 解释是否像人
     * 流程是否顺

👉 因此，本版本 **完全移除 ReAct 设计**，
改为 **LLM 直接做决策 + 系统强约束输出协议**。

---

## 2. Design Doc 004 的核心目标

> 从
> **「看起来很聪明的 Agent 架构」**
> 收敛为
> **「用户明确感知到在和 AI 协作完成一件事」**

### 三条不可动摇的原则

1. **流程必须可感知**
2. **决策必须可解释**
3. **用户必须随时能介入**

---

## 3. 总体架构（v3.0）

```text
┌──────────────────────────────────────────────┐
│                Web UI                       │
│ Explorer | Viewer | Chat                    │
│ Task Progress / Step Indicator / Actions    │
└───────────────┬──────────────────────────────┘
                │ REST / SSE
┌───────────────▼──────────────────────────────┐
│              FastAPI Server                  │
│ Session / Task / Message / Action API        │
└───────────────┬──────────────────────────────┘
                │
┌───────────────▼──────────────────────────────┐
│              Task Manager                    │
│ - Task 生命周期                              │
│ - Stage 状态                                 │
│ - 用户操作记录                              │
└───────────────┬──────────────────────────────┘
                │
┌───────────────▼──────────────────────────────┐
│        LLM Decision & Explanation Layer      │
│ - 决定下一步                                 │
│ - 生成用户解释                               │
│ - 生成用户引导                               │
└───────────────┬──────────────────────────────┘
                │
┌───────────────▼──────────────────────────────┐
│          Stage Generator (LLM)               │
│ - 单阶段内容生成                             │
│ - 严格输入 / 输出协议                        │
└───────────────┬──────────────────────────────┘
                │
┌───────────────▼──────────────────────────────┐
│        Knowledge & Tool Layer                │
│ - Knowledge Templates                        │
│ - Web Search（可选）                         │
│ - Tool 状态可感知                            │
└──────────────────────────────────────────────┘
```

---

## 4. 核心概念定义（统一认知）

### 4.1 Task（任务）

> **一次完整课程设计 = 一个 Task**

```json
Task {
  task_id: string,
  session_id: string,
  topic: string,
  stages: string[],
  current_stage: string,
  completed_stages: string[],
  status: "active" | "completed",
  created_at: timestamp
}
```

---

### 4.2 Stage（阶段）

* Stage 是 **流程单位**
* 每个 Stage：

  * 只做一件事
  * 必须有「用户确认点」

示例：

```text
- goal_definition
- driving_question
- question_chain
- activity_design
- assessment
- reflection
```

---

## 5. LLM Decision & Explanation Layer（核心）

> **这是整个系统“像 Agent”的唯一来源**

### 5.1 它负责什么

✅ 决定下一步
✅ 判断是否可以推进
✅ 告诉用户为什么
✅ 告诉用户接下来要干嘛

❌ 不生成内容
❌ 不调用工具

---

### 5.2 输入

```json
{
  "task": { ... },
  "current_stage": "driving_question",
  "stage_status": "completed",
  "user_action": "accept",
  "component_validity": {
    "driving_question": true
  }
}
```

---

### 5.3 输出（**必须直接展示给用户**）

```json
{
  "next_stage": "question_chain",
  "explanation": "驱动问题已经确认，现在需要帮助学生形成清晰的思考路径。",
  "user_message": "下一步我会为你生成一组问题链，你可以在生成后逐条调整。"
}
```

> ⚠️ **explanation / user_message 不允许只写给系统**

---

## 6. Stage Generator（LLM 内容生成器）

### 6.1 设计原则

* 一个 Stage = 一次 LLM 调用
* 输入极简、结构明确
* 输出必须结构化

---

### 6.2 输入示例

```json
{
  "stage": "driving_question",
  "topic": "AI 如何识别交通标志",
  "constraints": {
    "grade": "初二",
    "course_duration": 45
  },
  "knowledge_refs": ["curriculum_standard"]
}
```

---

### 6.3 输出示例

```json
{
  "pending_component": "driving_question",
  "candidates": [
    {
      "id": "A",
      "title": "AI 能看懂路标吗？",
      "rationale": "贴近生活场景，容易引发兴趣"
    },
    {
      "id": "B",
      "title": "如果没有人教，AI 怎么认识交通标志？",
      "rationale": "强调学习过程"
    }
  ]
}
```

---

## 7. Knowledge Templates（知识即“显式参考”）

### 7.1 不做 RAG 的原因

* 教育场景：

  * 确定性 > 覆盖率
* 课程标准不能“漂”

---

### 7.2 使用方式

```text
knowledge/
├── curriculum_standard.md
├── pbl_principles.md
├── age_guidelines.json
├── common_pbl_mistakes.md
```

### 7.3 用户可感知提示

> ℹ️ 本步骤参考了《课程标准》中关于真实性任务的要求。

---

## 8. Tool Layer（完全用户可控）

### 8.1 工具不自动触发

* 所有工具：

  * 必须由用户触发
  * 必须展示状态

---

### 8.2 Tool 状态消息协议

```json
{
  "type": "tool_status",
  "tool": "web_search",
  "status": "running",
  "message": "正在查找真实教学案例..."
}
```

---

## 9. 用户可感知消息模型（统一）

系统对话 **只允许三类消息**：

### 1️⃣ 状态说明

> 🤖 正在生成驱动问题（第 2 / 6 步）

### 2️⃣ 决策解释

> ℹ️ 因为课程目标已经明确，现在需要设计学生的思考路径。

### 3️⃣ 行动引导

> ✋ 我生成了 2 个方案，你可以选择一个或直接修改。

---

## 10. 数据流（完整一次）

1. 创建 Session
2. 创建 Task
3. Decision Layer 决定起始 Stage
4. Stage Generator 生成内容
5. 用户确认 / 编辑
6. Decision Layer 解释并推进
7. 所有 Stage 完成 → Task 完成
8. 提示导出课程方案

---

## 11. 关键架构共识（写给未来的自己）

* ❌ 不追求推理“看起来很高级”

* ✅ 追求用户“感觉在一起做事”

* ❌ 不让用户理解 Agent 架构

* ✅ 让用户理解 **AI 的意图**
